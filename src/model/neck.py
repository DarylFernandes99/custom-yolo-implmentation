import torch
from torch import nn
from typing import List

from src.model.model_blocks import Conv, C3K2

class Neck(nn.Module):
    def __init__(self, width: List[int], depth: List[int], csp: List[bool]):
        """
        The Neck connects the backbone and the head, focusing
        on aggregating and refining the multi-scale features
        generated by the backbone. It fuses both high-level
        semantic and low-level fine-grained information,
        which is crucial for detecting objects of diverse
        sizes effectively.

        Parameters:
        -----------
        width : List[int]
            A list of integers representing the width of
            different layers.
        depth : List[int]
            A list of integers representing the depth of
            different layers.
        csp : List[bool]
            A list of Boolean values representing whether
            to use CSP (Cross Stage Partial) module for
            each layer.
        """
        super().__init__()
        self.up = nn.Upsample(scale_factor=2)
        self.h1 = C3K2(width[4] + width[5], width[4], depth[5], csp[0], r=2)
        self.h2 = C3K2(width[4] + width[4], width[3], depth[5], csp[0], r=2)
        self.h3 = Conv(width[3], width[3], nn.SiLU(), k=3, s=2, p=1)
        self.h4 = C3K2(width[3] + width[4], width[4], depth[5], csp[0], r=2)
        self.h5 = Conv(width[4], width[4], nn.SiLU(), k=3, s=2, p=1)
        self.h6 = C3K2(width[4] + width[5], width[5], depth[5], csp[1], r=2)

    def forward(self, x):
        p3, p4, p5 = x
        p4 = self.h1(torch.cat(tensors=[self.up(p5), p4], dim=1))
        p3 = self.h2(torch.cat(tensors=[self.up(p4), p3], dim=1))
        p4 = self.h4(torch.cat(tensors=[self.h3(p3), p4], dim=1))
        p5 = self.h6(torch.cat(tensors=[self.h5(p4), p5], dim=1))
        return p3, p4, p5
